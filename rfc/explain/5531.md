# Understanding ONC RPC (Remote Procedure Call)

Imagine you are playing with a toy robot. Usually, you press a button on its back, and it walks. But what if the robot is in another room? You would need a remote control to send a signal telling the robot to walk. 

In the world of computers, **Remote Procedure Call (RPC)** is that remote control. It lets one computer ask another computer to do a task as if it were doing the task itself.

### 1. What Problem Does This Protocol Solve?

Normally, when a programmer writes code, they use "local" procedures. This is like reaching into your own toy box to grab a block. It is fast and easy because everything is right there in the computer's own memory.

However, sometimes a computer isn't powerful enough to do a big job, or it doesn't have the data it needs. That data might be on a big server far away. The problem is that talking to another computer over a network is messy. You have to worry about:
*   **Different Languages:** One computer might store numbers differently than another (Section 1).
*   **Lost Messages:** The network might drop your request (Section 5).
*   **Security:** How do you know the computer asking for data is allowed to see it? (Section 7).

RPC solves this by creating a "standard way" to send these requests. It hides the "network" part so the programmer can focus on the "work" part (Section 4).

### 2. Key Concepts and Terminology

To understand RPC, you need to know a few "computer words":

*   **Client and Server:** The **Client** is the computer that asks for help. The **Server** is the computer that does the work and sends back an answer (Section 3).
*   **Programs and Procedures:** A **Program** is a collection of tasks (like a "File Service"). A **Procedure** is one specific task inside that program (like "Read a File") (Section 3).
*   **Version Number:** Protocols change over time. The version number ensures the Client and Server are talking about the same set of rules (Section 8.1).
*   **XDR (External Data Representation):** This is the "Universal Translator." It makes sure that if a Client sends the number `5`, the Server sees it as `5`, even if they usually speak different digital languages (Section 1).
*   **XID (Transaction ID):** This is like a ticket number at a deli. When the Client sends a request, it attaches an XID. When the Server replies, it uses the same XID so the Client knows which answer goes with which question (Section 9).

### 3. How the Protocol Works (The High-Level Flow)

The RPC model follows a specific "Wait and See" flow (Section 4):

1.  **The Request:** The Client wants to do something (like "Add 2 + 2"). It packs a "Call Message" containing the Program number, Procedure number, and the numbers `2` and `2`. It also adds its "ID card" (Authentication) and a ticket number (XID) (Section 9).
2.  **The Journey:** The message is sent over the network. RPC doesn't care if it travels by "reliable" methods like TCP or "unreliable" ones like UDP, but the programmer needs to know which one is being used so they can handle lost messages (Section 5).
3.  **The Server Wakes Up:** The Server is usually "dormant" (sleeping). When the message arrives, it wakes up, looks at the "ID card" to make sure the Client is allowed to ask, and then does the math (Section 4).
4.  **The Reply:** The Server packs the answer (`4`) into a "Reply Message" using the same ticket number (XID) and sends it back (Section 9).
5.  **The Result:** The Client receives the message, matches the XID, and continues its work as if it had done the math itself (Section 4).

### 4. Common Use Cases

Why do we use this? Here are a few real-world examples:

*   **Network File System (NFS):** This is the most common use of RPC. It allows your computer to see files that are actually stored on a different server. When you click "Open File," your computer uses RPC to ask the server to "Read" the bits and send them over (Section 3).
*   **Ping Services:** A simple program used to see if another computer is "awake." The Client sends a "Null" procedure (Procedure 0), which does nothing but ask for a reply. If the reply comes back, the server is alive (Section 12.1).
*   **Batching:** If a Client has 100 small tasks to do, it can send them all at once without waiting for an answer for each one. This saves a lot of time on slow networks (Section 8.4.1).
*   **Broadcasting:** A Client can send one RPC message to *every* computer on a network at once to see who can help with a specific task (Section 8.4.2).

By using RPC, computers can work together as a team, making the whole network feel like one giant, powerful machine.